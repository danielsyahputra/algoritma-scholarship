---
title: "Time Series & Forecasting : Inclass Material"
author: "Inayatus"
date: "`r format(Sys.Date(), '%B %e, %Y')`"
output: 
  html_document:
    toc: true
    toc_float: 
      collapsed: no
    number_sections: true
    df_print: paged
    theme: cosmo
    highlight: tango
    css: assets/inclass_style.css
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
# chunk options
knitr::opts_chunk$set(
  message = FALSE,
  warning = FALSE,
  fig.align = "center",
  comment = "#>"
)

# load library

library(dplyr) # data wrangling
library(lubridate) # date manipulation
library(forecast) # time series library
library(TTR) # for Simple moving average function
library(MLmetrics) # calculate error
library(tseries) # adf.test
library(fpp) # usconsumtion
library(TSstudio) # mempercantik visualisasi timeseries
library(ggplot2)
library(tidyr)
```

```{=html}
<style>
body { 
text-align: justify}
</style>
```
# Time Series and Forecasting

```{r echo=FALSE}
knitr::include_graphics("assets/Time Series Forecasting.png")
```

**Glossary**:

1.  Timeseries: Data yang berhubungan dengan waktu.
2.  Forecasting: Prediksi/Peramalan dimasa depan.
3.  Objek ts: untuk analisis time series di R, kita perlu convert
    dataframe menjadi objek ts.

-   Data: Pilih satu variabel yang ingin diamati
-   start: periode awal data kita.
-   frequency: untuk penentuan pola musiman yang ingin diperhatikan.

4.  Seasonal Adjustment: Penyesuaian musiman, data yang sudah dilakukan
    proses penyesuaian musiman dapat menunjukkan pola (behaviour) yang
    riel dimana pengaruh musim sudah dikeluarkan dari data aslinya.
    (Bps, 2019).

# Working with Time Series

Apa itu time series? Apa perbedaannya dengan regresi atau yang lainnya?

Time series adalah suatu object dalam statistik dimana object tersebut
berhubungan dengan suatu deret waktu tertentu. Objek ini banyak ditemui
dalam kehidupan sehari-hari, contoh: harga daging sapi harian, curah
hujan bulanan, kuantitas penumpang bulanan, pendapatan tahunan, dll.

Perbedaan mendasar antara time series dengan regresi adalah jika pada
regresi untuk memprediksi suatu nilai Y dipengaruhi oleh beberapa faktor
yaitu x1,x2,..,xn. Sedangkan jika **time series**, untuk memprediksi
suatu nilai Y dipengaruhi oleh nilai Y itu sendiri pada masa lampau
($Y_{t-1}$).

Analisis time series berhubungan dengan suatu data yang memiliki nilai
numerik pada interval waktu tertentu. Proses untuk memprediksi nilai
pada anilisis time series disebut sebagai peramalan atau
**forecasting**. Ide utama dalam melakukan forecasting itu adalah
korelasi dari data numerik.

## Karakteristik Data Time Series

Time series data: data yang berhubungan dengan waktu dan memiliki
interval waktu yang tetap/sama.

üí° Syarat utama data time series:

1.  Data harus urut sesuai periode waktu dari data terlama sampai ke
    data terbaru
2.  Interval waktunya harus tetap/sama
3.  Tidak boleh ada data yang terlewat untuk setiap interval
4.  Tidak boleh ada yang missing

‚ùì **Knowledge Check**

Apakah data berikut sudah memenuhi syarat data time series yang baik?

1.  Demand product

```{r}
df_demand <- data.frame(
  date = ymd(c("2021-5-3", "2021-5-4", "2021-5-6", "2021-5-7")),
  demand = c(29, 79, 41, 88)
  )

df_demand
```

```{r}
# inspect periode terlewat
all(seq.Date(from = as.Date("2021-05-03"), to = as.Date("2021-05-07"), by = "day") == df_demand$date)
```

**Kesimpulan:** data masih belum memenuhi karakteristik data time
series, karena ada tanggal yang kosong yaitu di tanggal 5.

2.  Price product

```{r}
df_price <- data.frame(
  date = ymd(c("2021-5-16", "2021-5-19", "2021-5-18", "2021-5-17", "2021-5-20", "2021-5-21")),
  price = c(1000, 1001, 1002, 1003, 1004, 1005)
  )

df_price
```

**Kesimpulan:** belum tepat karena periode belum terurut

üí° Perbaikan yang dapat dilakukan sesuai syarat time series:

-   Mengurutkan data berdasarkan waktu: `arrange()`

```{r}
# mengurutkan df_price
df_price %>% 
  arrange(date)
```

-   Melakukan padding untuk memastikan interval data sama: `pad()` dari
    package `padr`

Secara default, `pad()` akan menambal periode waktu (tanggal)
berdasarkan kolom yang tipe datanya date. Mengisi nilai yang terlewat
atau missing (`NA`), cara yang umum dilakukan dengan package `zoo`:

-   `na.fill()`: mengisi `NA` dengan sebuah nilai, Gunakan
    `fill="extend"` untuk mengisi dengan nilai rata-rata dengan nilai
    yang missing
-   `na.aggregate()`: nilai aggregasi (mean, median)
-   `na.locf()`: nilai terakhir sebelum missing

Note: metode untuk mengisi missing value disesuaikan dengan perspektif
dari businessnya.

```{r}
# case: toko tutup di tanggal 5
# kita isi NA dengan nilai 0
anyNA(df_demand)
library(padr)
library(zoo)
df_demand %>% 
  pad(start_val = min(df_demand$date), end_val = max(df_demand$date)) %>% 
  mutate(demand = na.fill(demand, 0))
```

## Time Series Object

Kita akan menggunakan data emisi CO2 di Indonesia dimana datanya sudah
tersimpan dalam folder data_input dengan nama `environment_1970f.csv`.
Dari data `co2` ini, kita akan menggunakan 2 kolom yang kita butuhkan
yaitu kolom `year` untuk menunjukkan waktu dan
`CO2.emissions..metric.tons.per.capita.` sebagai nilai Y yang kita amati
untuk membuat object `ts`.

Untuk membuat sebuah object time series pada R kita bisa menggunakan
function `ts()` dengan parameter yang diperlukan yaitu :

> ts(data, start, frequency)

-   `data` = data yang akan kita prediksi
-   `start` = waktu awal mula data yang akan diprediksi
-   `frequency` = pola berulang dari data

```{r, echo=FALSE}
data.frame(
  Data = c("Annual","Quarterly", "Monthly", "Weekly"),
  Frequency = c(1,4,12,52)
)
```

```{r, echo = FALSE}
data.frame(
  Data = c("Daily", "Hourly", "Minutes", "Seconds"),
  Minute = c("-", "-", "-", "60"),
  Hour = c("-", "-", "60", "60*60"),
  Day = c("-", "24", "60*24", "60*60*24"),
  Week = c("7", "24*7", "60*24*7", "60*60*24*7"),
  Month = c("7*4", "24*7*4", "60*24*7*4", "60*60*24*7*4"),
  Year = c("7*4*12", "24*7*4*12", "60*24*7*4*12", "60*60*24*7*4*12")
)
```

**Latihan :**

1.  data **jam** -> pola **harian** -> freq = 24
2.  data **harian** -> pola **mingguan** -> freq = 7
3.  data **harian** -> pola **weekday** -> freq = 5
4.  data **jam** -> pola **mingguan** -> freq = 24\*7 atau 168
5.  data **bulanan** -> pola **tahunan** -> freq = 12
6.  data **bulanan** -> pola **kuartalan** -> freq = 3
7.  data **tahunan** -> pola **tahunan** -> freq = 1

**Langkah awal dalam membuat object time series:**

Kita akan gunakan data emisi CO2 dimana datanya sudah tersimpan dalam
folder data_input dengan nama `environment_1970f.csv`.

-   read data

```{r}
# read data co
co2 <- read.csv("data_input/environment_1970f.csv")
head(co2)
```

Data `co2` terdiri dari 43 observasi yang mewakili kontribusi gas emisi
per tahun terhadap atmosfer Indonesia (43 tahun, 1970-2012). Data ini
terdiri dari 7 variabel, yaitu:

-   `year`: tahun.
-   `emisi co2 (kt)`: emisi yang berasal dari pembakaran bahan bakar
    fosil dan pembuatan semen, termasuk yang dihasilkan selama konsumsi.
-   `emisi co2 (metrik ton per kapita)`: `idem`.
-   `emisi metana (kt setara co2)`: emisi yang berasal dari aktivitas
    manusia (pertanian) dan dari produksi metana industri.
-   `emisi nitro oksida (ribu metrik ton setara co2)`: emisi dari
    pembakaran biomassa pertanian, kegiatan industri, dan pengelolaan
    ternak.
-   `emisi gas rumah kaca dan lainnya, HFC, PFC dan SF6 (ribu metrik ton setara co2)`:
    emisi hasil samping dari hidrofluorokarbon, perfluorokarbon, dan
    sulfur hexafluoride.
-   `total emisi gas rumah kaca (setara dengan co2)`: total CO2 tidak
    termasuk pembakaran biomassa siklus pendek (pembakaran limbah
    pertanian dan savannah), tetapi termasuk pembakaran biomassa lainnya
    (kebakaran hutan, pembusukan pasca-pembakaran, kebakaran gambut, dan
    pembusukan lahan gambut yang dikeringkan), semua sumber CH4
    antropogenik, sumber N2O dan gas-F (HFC, PFC, dan SF6).

Dari data `co2` ini, kita akan menggunakan 2 kolom yang kita butuhkan
yaitu kolom `year` untuk menunjukkan waktu dan
`CO2.emissions..metric.tons.per.capita.` sebagai nilai Y yang kita amati
untuk membuat object `ts`.

-   mengetahui range atau periode waktu data time series

untuk mengetahui periode waktu data time series dari awal hingga akhir
kita bisa menggunakan fungsi `range()`.

```{r}
range(co2$year)
# memastikan datanya lengkap untuk periode waktunya
all(1970:2012 == co2$year)
# untuk mengurutkan data berdasarkan periode waktu
co2 <- co2 %>% 
  arrange(year)
```

-   mengetahui frequency atau banyak data dalam satu pola musiman

untuk mengetahui frequency data yang dimiliki dapat diinspect
berdasarkan:

1.  data yang disusun per periode apa
2.  pola yang ingin dilihat apa
    (harian/mingguan/bulanan/kuartalan/tahunan)

-   cek apakah data sudah memenuhi syarat data time series yang baik?

    -   pastikan terurut: sudah terurut
    -   interval waktunya tetap: sudah tetap
    -   tidak ada waktu yang terlongkap: tidak ada

```{r}
# untuk mengetahui apakah periode sudah terurut

# untuk cek missing value

```

-   membuat object ts dengan `ts()` function

```{r}
# simpan dalam object co2_ts
co2_ts <- ts(data = co2$CO2.emissions..metric.tons.per.capita., start = 1970, frequency = 1)

co2_ts
```

```{r}
# contoh pembuatan object ts tanpa menuliskan parameter start 
object_ts <- ts(co2$CO2.emissions..metric.tons.per.capita., frequency = 1)
```

-   memvisualisasikan data time series untuk melihat pola datanya

```{r}
# inspect pola data
co2_ts %>% autoplot()
```

**Insight :**

-   emisi CO2 dalam 40 tahun terakhir memiliki kecenderungan untuk naik

-   emisi CO2 pada tahun 2010-2011 naik cukup drastis

-   disekitaran tahun 1997-1998 terjadi penurunan emisi gas CO2

-   dari plot diatas, misalkan kita ingin melakukan subset periode pada
    object `ts` dapat menggunakan fungsi `window()`

> window(object_ts, start, end)

Misalkan dari data `co2_ts` kita ingin mensubset periode dari 1995-2000

```{r}
# window
window(co2_ts, start = 1995, end = 2000) %>% autoplot()
```

------------------------------------------------------------------------

**Dive Deeper**

Kita akan coba menggunakan data `births` terdiri dari 168 observasi
tingkat kelahiran per bulan di New York. Data ini terdiri dari 2
variabel, yaitu:

-   `date`: tanggal.
-   `births`: tingkat kelahiran.

> data birth data tingkat kelahiran di new york city dari tahun Jan 1946
> - Des 1959

-   Read data `nybirth.csv`

```{r}
# read nybirth.csv
birth <- read.csv("data_input/nybirth.csv")
tail(birth)
```

```{r}
birth <- birth %>% 
  mutate(date = ymd(date)) %>% 
  arrange()

urutan_periode <- seq.Date(from = as.Date("1946-01-01"), to = as.Date("1959-12-01"), by = "month")
all(urutan_periode == birth$date)
```

-   membuat object ts dari data `birth` dan disimpan dalam object
    `birth_ts` dengan data yang terkumpul adalah data bulanan dengan
    pola yang ingin dilihat adalah tahunan

```{r}
# answer here
birth_ts <- ts(data = birth$births, start = c(1946, 1), frequency = 12)
birth_ts
```

-   Visualisasi object `birth_ts` menggunakan `autoplot()`

```{r}
birth_ts %>% autoplot()
```

**Insight:**

-   data birth memiliki pola musiman
-   trend pergerakan kelarihan bayi sebelum tahun 1950 terlihat menurun,
    namun setelah tahun 1950 cenderung naik

## Decomposition

Decomposition adalah suatu tahapan dalam time series analisis yang
digunakan untuk menguraikan beberapa komponen dalam time series data.

üí° Komponen dalam time series :

-   **Trend** : pola data secara general, cenderung untuk naik atau
    turun. Jika ada trend masih terdapat pola artinya masih ada pola
    yang belum terurai dengan baik.
-   **Seasonal** : pola musiman yang membentuk pola berulang pada
    periode waktu yang tetap
-   **Error/Reminder/Random** : pola yang tidak dapat ditangkap dalam
    trend dan seasonal

Sebelum melakukan modeling forecasting kita perlu mengamati objek
timeseries dari hasil `decompose`. Ide utama dari decompose adalah untuk
menguraikan ketiga komponen dari objek ts (trend, seasonal, residual).

> Jika pada hasil decompose, trend masih membetuk sebuah pola maka dapat
> dicurigai masih ada seasonality yang belum ditangkap. Seharusnya trend
> cenderung naik atau cendurung turun.

Untuk dapat menguraikan data time series kita menjadi 3 komponen
tersebut, kita dapat menggunakan fungsi `decompose()`.

```{r}
birth_decom <- decompose(x = birth_ts)
```

Memvisualisasikan hasil decompose menggunakan `autoplot()` dari package
`forecast`

```{r}
# autoplot
birth_decom %>% autoplot()
```

```{r}
birth_decom
```

```{r}
birth %>% 
  mutate(date = ymd(date),
         month = month(date, label = T),
         seasonal = birth_decom$seasonal) %>% 
  distinct(month, seasonal) %>% 
  ggplot(aes(month, seasonal))+
  geom_col()
```

```{r}
birth_clean <- birth %>% 
  mutate(date = ymd(date),
         month = month(date, label = T))
ggplot(data = birth_clean, aes(x = date, y = births)) +
  geom_point() +
  geom_point(data = birth_clean %>% 
               filter(month %in% c("Jan", "Feb", "Jul")),
             aes(col = month)) +
  geom_line() +
  scale_color_manual(values = c("red", "blue", "yellow"))
```

Pada hasil decompose kita mendapatkan informasi visualisasi:

1.  Data : pola data asli
2.  Seasonal (S) : pola musiman atau pola berulang dari data
3.  Trend (T) : pola data secara global (naik atau turun)
4.  Remainder (E) : pola data yang tidak dapat ditangkap oleh seasonal
    dan trend

üí° **Notes:** Jika pada hasil decompose, trend masih membentuk sebuah
pola maka dapat dicurigai masih ada seasonality yang belum ditangkap.
Seharusnya trend cenderung naik atau cenderung turun secara smooth.
Penyebabnya:

-   frequency yang kita tetapkan belum tepat, atau
-   terdapat multiseasonality pada data (pola berulang lebih dari satu,
    visitor bioskop)

```{r}
birth_decom %>% autoplot()
```

## Knowledge Check

1.  Manakah pernyataan di bawah ini yang salah terkait data time series?

-   [ ] Data time series harus disusun secara berurut sesuai waktu
    dengan interval waktu yang tetap.
-   [ ] Data time series dapat diurai menjadi pola trend, seasonal, dan
    error.
-   [ ] Data time series disebut additive karena variasi seasonalnya
    relatif konstan dari waktu ke waktu.
-   [x] Data time series disebut multiplicative karena menunjukkan trend
    yang linear.

2.  Misalkan kita memiliki object retail merupakan dataframe penjualan
    bulanan dari tahun 2010 sampai 2015. Kita ingin menganalisis
    pergerakan nilai pada kolom sales dari dataframe retail. Cara
    membuat object ts dengan pola seasonality tahunan adalah ...

-   [ ] ts(retail, frequency = 1)
-   [ ] ts(retail, frequency = 12)
-   [ ] ts(retail\$sales, frequency = 1)
-   [x] ts(retail\$sales, frequency = 12)

3.  Decompose adalah bagian dari eksplorasi data pada analisis time
    series. Berikut adalah manfaat dari melakukan decompose, kecuali ...

-   [ ] Mengetahui pola naik atau turun-nya data dari trend.
-   [ ] Dapat digunakan untuk analisis pola musiman dari pola
    seasonality.
-   [x] Mengetahui nilai di waktu yang akan datang berdasarkan pola data
    historis.
-   [ ] Mengetahui apakah frequency yang diatur dalam object time series
    sudah sesuai atau belum.

```{r echo=FALSE}
knitr::include_graphics("assets/decompose.png")
```

Gambar tersebut menunjukkan hasil decomposition untuk data time series
terkait tingkat kejahatan harian di Chicago dari tahun 2014 sampai
dengan 2019.

4.  Berdasarkan grafik tersebut, bagaimana pola trend yang terdapat pada
    data?

-   [ ] tidak terdapat pola tertentu
-   [x] pola meningkat
-   [ ] pola menurun
-   [ ] pola naik turun secara berulang

## Additive vs Multiplicative Time Series

```{r echo=FALSE}
knitr::include_graphics("assets/seasonaltypes.gif")
```

Ada 2 jenis model pada data time series, yaitu :

1.  **Model Additive** : Model time series yang memiliki varians konstan
    mengikuti trend dan seasonalnya

$$Y_t = T_t + S_t + E_t$$

Data = Trend + Seasonal + Error

2.  **Model Multiplicative** : Model time series yang memiliki varians
    semakin tinggi/rendah mengikuti trend dan seasonal yang ada

$$Y_t = T_t * S_t * E_t$$

Data = Trend \* Seasonal \* Error

### Additive Time Series

Jika kita perhatikan lagi pada data `birth_ts` memiliki pola additive,
karena varians dari polanya tetap atau konstan. Untuk melakukan
decompose pada pola additive tambahkan parameter `type = "additive"`
dimana secara default fungsi `decompose()` memiliki type = "additive".

```{r}
# additive time series
birth_ts %>% autoplot()
```

**Melakukan inspect komponen time series padaa data `birth_dc`**

**1. Trend**

Trend diperoleh dari hasil perhintungan `center moving average (CMA)`.
Tujuan utamanya untuk smoothing data sehingga diperoleh trend yang
cenderung naik/ cenderung turun.

Trend = Data - Seasonality - Error

```{r}
birth_decom$trend %>% autoplot()
```

**Pendekatan manual menddungkan Center Moving Average**

```{r}
birth_trend <- ma(x = birth_ts, order = 12, centre = T)
birth_trend %>% autoplot()
# birth_trend %>% ts_plot()
```

```{r}
birth_decom$trend %>% autoplot()
```

**2. Seasonal**

Karena polanya additive maka:

*Seasonal + Error = Data - Trend*

```{r}
birth_decom$seasonal %>% autoplot()
```

**Pendekatan manual**:

```{r}
# matematic didalamnya
sea.err_birth <- birth_ts-birth_trend
sea.err_birth %>% autoplot()

# mean of each month
mean.month_birth <- sea.err_birth %>% 
  matrix(ncol =  12, byrow = T) %>% 
  colMeans(na.rm = T)

# mean global
mean.glob_birth <- mean(mean.month_birth)

# Seasonality Calculation
birth_seasonal <- ts(rep(mean.month_birth - mean.glob_birth, 12), start = start(birth_ts), frequency = 12)
 
birth_seasonal %>% autoplot()
```

**3. Error**

Untuk memperoleh informasi error pada model additive, dapat menggunakan
rumus:

*Error = Data - Trend - Seasonal*

```{r}
birth_decom$random %>% autoplot()

# matematis didalamnya

birth_error <- birth_ts - (birth_trend + birth_seasonal)
birth_error %>% autoplot()
```

### Analisis Seasonal

Untuk dapat melakukan analisis seasonal, kita bisa lakukan dengan cara
melakukan inputasi komponen seasonal yang ada.

```{r}
birth %>% 
  mutate(monthly = month(date, label = T, abbr = F),
         seasonality = birth_decom$seasonal) %>% 
  distinct(monthly, seasonality) %>% 
  ggplot(aes(x = monthly, y = seasonality)) +
  geom_col()+
  theme_minimal()
```

```{r}
birth_ts %>% seasonplot()
```

### Multiplicative Time Series

Jika kita memiliki pola multiplicative pada data time series dan ingin
membuat decomposenya cukup menambahkan `type = "multiplicative"` pada
fungsi `decompose()`.

Ketika kita menemukan pola data kita mengandung multiplikative :

> cara 1: membuat data multiplikative tersebut menjadi additive dengan
> fungsi `log`. Setelah memperoleh hasil forecast kita dapat
> mengembalikan nilainya dengan `exp`.

```{r}
AirPassengers %>% autoplot()
decompose(AirPassengers, type = "multiplicative") %>% autoplot()
```

```{r}
# transformasi log agar data menjadi tipe additive
log(AirPassengers) %>% autoplot()
```

(Opsional) Sifat logaritma: perkalian menjadi penjumlahan

$$y = T * S * E$$ -> multiplicative $$log(y) = log(T * S * E)$$
$$log(y) = log(T) + log(S) + log(E)$$ -> additive

> Cara 2: Tetap menggunakan model multiplicative, kemudian nanti hasil
> dibandingkan dengan memilih model dengan error yang paling kecil.

Parameter `type` dalam fungsi `decompose()`, secara default
`type = "additive"`

multi:

1.  transformasi/scaling -> additive
2.  decompose, dengan catatan selalu tambahkan parameter yang
    menjelaskan bahwa datanya adalah multiplicative

```{r}
air_decom <- decompose(x = AirPassengers, type = "multiplicative")
air_decom %>% autoplot()
```

-   Trend

Trend = Data / (Seasonal \* Error)

```{r}
air_decom$trend %>% autoplot()
```

```{r}
# proof manual
air_trend <- ma(AirPassengers, order = 12, centre = T)
air_trend %>% autoplot()
```

-   Seasonal

Seasonal\*Error = Data / Trend

```{r}
air_decom$seasonal %>% autoplot()
```

```{r}
# proof manual
air_seas_error <- AirPassengers/air_trend

mean_air_seas <- air_seas_error %>% 
  matrix(ncol = 12, byrow = T) %>% 
  colMeans(na.rm = T)
air_seasonal <- ts(rep(mean_air_seas, 12), start = c(1949, 1), frequency = 12)
air_seasonal %>% autoplot()
```

-   Error

Error = Data / (Trend\*Seasonal)

```{r}
air_decom$random %>% autoplot()
```

```{r}
# proof manual
air_error <- AirPassengers/ (air_trend*air_seasonal)
air_error %>% autoplot()
```

Decompose dapat kita gunakan untuk melakukan analisis seasonal dengan
tujuan untuk mendapatkan insight dari efek seasonal yang ada.

Tujuan dan manfaat melakukan decompose : 1. Mengidentifikasi tipe time
series yang kita miliki, multiplicative atau additive 2. Kita mengetahui
komponen trend, seasonal, dan error pada data kita 3. Bisa melakukan
analisis seasonal untuk mengetahui pergerakan data tertinggi dan
terendah diperiode apa, utnuk tujuan bisnis

### Summary Day 1

-   Time series : data yang tersusun berdasarkan periode waktu dengan
    interval waktu yang sama

-   Karaktersitik time series:

    -   periode waktunya berurut
    -   data tidak ada yang kosong / missing
    -   periodenya tidak ada yang terlewat

-   Untuk memvisualisasikan data time series bisa menggunakan fungsi
    `autoplot()`

-   `ts()` digunakn untuk membuat object time series

    -   `data` : variabel yang akan dianalisis
    -   `start` : optional, berupa informasi awal mula periode time
        series yang dimiliki
    -   `frequency` : pola musiman yang akan dilihat

```{r eval=FALSE}
# contoh data denagn frequency=1 tidak dapat di decompose
co2_ts %>% decompose()
```

-   Decompose : untuk melakukan ekstraksi komponen yang ada pada time
    series

    -   trend : pola general pada data, kalau tidak naik ya turun
        polanya
    -   seasonal : pola berulang / musiman
    -   eror/reminder/random : pola yang tidak dapat ditangkap oleh
        trend dan seasonal

-   Tipe time series:

    -   additive: tipe time series ketika semakin bertambah periode,
        besaran seasonalnya tetap/konstan
    -   multiplicative: tipe time series ketika semakin bertambah
        periode, besaran seasonalnya bisa bertambah besar/kecil

**END OF DAY 1**

# **START DAY 2**

### Seasonality Adjustment

Objek time series yang telah dihilangkan efek seasonalnya.

Tujuan dari seasonality adjusment adalah untuk mengetahui pola data time
series yang dimiliki tanpa memperhitungkan efek seasonal yang ada pada
data. Hal ini akan sangat berguna untuk melakukan analisis lebih lanjut
dalam pengambilan suatu keputusan.

1.  Read data `AirPassanger`

```{r}
AirPassengers
```

Data `AirPassanger` merupakan data banyaknya penumpang pesawat terbang
dari bulan Jan 1949 - Des 1960.

2.  Membuat visualisasi

```{r}
AirPassengers %>% autoplot()
class(AirPassengers)
air_df <- data.frame(date = seq(from = ymd("1949-01-01"), to = ymd("1960-12-01"), by = "month"), 
                     value = as.data.frame(AirPassengers)$x) 
air_df <- air_df %>%
  mutate(monthly = month(date, label = T))
air_df %>% 
  ggplot(aes(x = date, y =value))+
    geom_point(data = air_df %>% filter(monthly == "Jul"), col = "firebrick")+
    geom_point(data = air_df %>% filter(monthly == "Des"), col = "blue")+
  geom_line()
```

4.  Melakukan decomposition

Melakukan decomposition pada data `AirPassengers` dengan `cara 2`

```{r}
air_dc <- AirPassengers %>% decompose(type = "multiplicative")
```

5.  Menghilangkan efek seasonality dengan menggunakan fungsi `seasadj`
    dari package `forecast`

```{r}
air_df <- air_df %>% 
  mutate(seasadj = seasadj(air_dc))
air_df %>% 
  ggplot(aes(x = date, y = seasadj))+
  geom_point(data = air_df %>% filter(monthly == "Jul"), col = "firebrick")+
  geom_point(data = air_df %>% filter(monthly == "Des"), col = "blue")+
  geom_line()
```

> **Note**: Untuk analisis seasonal adjustment hanya digunakan untuk
> explorasi data saja. Selebihnya ketika ingin melanjutkan modeling,
> kita tetap menggunakan data asli dimana data yang masih memiliki
> komponen trend, seasonal, dan errornya.

# Forecasting Model

üí° **Forecasting Model:**

1.  Simple Moving Average (SMA)

2.  Exponential Smoothing

    -   Simple Exponential Smoothing (SES)
    -   Double Exponential Smoothing (Holts Exponential Smoothing)
    -   Triple Exponential Smoothing (Holts Winter)

3.  Autoregresive Integrated Moving Average (ARIMA)

## Simple Moving Average (SMA)

Metode yang menggunakan rataan beregerak untuk melakukan forecasting.
Karena menggunakan rataan, bobot yang digunakan sama untuk setiap
observasi di masa lalu. Metode ini sering digunakan untuk data yang
tidak mengandung trend dan seasonal (datanya bergerak disekitar
rata-rata).

Fungsi yang digunakan untuk forecasting SMA adalah
`SMA(objek time series, n)` dari library `TTR`. Parameter yang
diugunakan, yaitu:

-   `x` :objek time series yang akan di forecast

-   `n`: jumlah observasi di masa lalu yang digunakan untuk forecasting

Kita akan coba melakukan forecasting pada data curah hujan tahunan sejak
1813-1912 yang tersimpan pada folder data_input dengan nama file
`precip1.dat`.

-   read data menggunakan `scan()`

```{r}
rain <- scan("data_input/precip1.dat", skip = 1)
head(rain)
```

-   membuat object ts

```{r}
rain_ts <- ts(data = rain, start = 1813, frequency = 1)
```

-   Visualisasikan data

```{r}
autoplot(rain_ts)
```

-   Melakukan forecasting menggunakan `SMA()` dengan ordo 3

```{r}
rain_sma3 <- SMA(x = rain_ts, n = 3)
```

```{r}
# forecast tahun 1913
future1913 <- mean(tail(rain_ts,2), 26.01000)
future1914 <- mean(tail(rain_ts, 1), 26.01000, future1913)
future1915 <- mean(26.01000, future1913, future1914)
future1913;future1914;future1915
```

```{r}
# contoh jika ordo diperbesar maka hasil forecast akan semakin smooth
rain_sma10 <- SMA(rain_ts, n = 10)
```

Memvisualisasikan data historis dengan hasil forecast

```{r}
rain_ts %>% autoplot()+
  autolayer(rain_sma3, series = "SMA(3)")+
  autolayer(rain_sma10, series = "SMA(10)")
```

**Kesimpulan**: Hasil forecast untuk model SMA(3) dapat mengikuti pola
data aktualnya, namun terdapat keterlambatan dalam mengikuti pola
datanya. Artinya model SMA(3) masih belum bisa melakukan forecast
terhadap data actual dengan baik.

üí° **Note:**

-   SMA tepat digunakan ketika data yang kita miliki tidak memiliki
    trend maupun seasonal (data stasioner).
-   penentuan ordo tidak ada rule of thumb nya
-   semakin besar ordo, semakin smooth datanya dan hasil forecastnya

## Exponential Smoothing

Metode SMA hanya mempertimbangkan n observasi di masa lampau untuk
melakukan forecast baik pola trend maupun seasonal cenderung tidak
tertangkap sehingga dibutuhkan metode lain yang memperhitungkan
keseluruhan data di masa lampau, yaitu metode eksponensial.

**Simple Exponential Smoothing** digunakan untuk data time series yang
**tidak mengandung trend dan seasonal**. Fungsi yang digunakan untuk
membuat model exponential smoothing, yaitu:

1.  `ets()` dari library `forecast` yang merupakan error, trend, dan
    seasonal. Parameter yang digunakan, yaitu:

-   objek timeseries yang digunakan.

-   model: model time series untuk `error, trend, dan seasonal`.

    -   `A`: aditif
    -   `M`: multiplikatif
    -   `N`: none
    -   `Z`: auto

-   alpha: bobot untuk smoothing eror, nilainya antara 0 - 1.

    -   \~ 1 observasi yang paling baru diberikan bobot yang paling
        tinggi tinggi dibandingkan dengan data periode lama
    -   \~ 0 observasi yang paling baru diberikan bobot yang paling
        tinggi tinggi namun perbedaannya sangat sedikit dengan data
        periode lama

-   beta: bobot untuk smoothing trend, nilainya antara 0 - 1.

-   gamma: bobot untuk smoothing seasonal, nilainya antara 0 - 1.

**SES**: ets(data, model = "\*NN")

**Holts exponential**: ets(data, model = "\*\*N")

**Holts Winter**: ets(data, model = "\*\*\*")

2.  `HoltWinters()`, parameter yang digunakan, yaitu:

-   objek timeseries yang digunakan.
-   secara default parameter `alpha`, `beta`, dan `gamma` adalah
    **NULL**, dimana apabila kita tidak mendefinisikan nilainya, maka
    model `HolWinters()` akan mencari nilai parameternya hingga
    mendapatkan nilai paling optimum. Sehingga jika objek time series
    tidak mengandung trend dan seasonal parameter `beta` dan `gamma`
    harus diubah menjadi **FALSE**.

**Simple Eksponential Smoothing**: HoltWinters(data, beta = F, gamma =
F)

**Holt's Exponential**: HoltWinters(data, gamma = F)

**Holt's Winter Explonential**: HoltWinters(data)

### Simple Exponential Smoothing (SES)

Simple Exponential Smoothing merupakan metode forecasting yang tepat
digunakan untuk data yang tidak memiliki trend maupun seasonal[^1].

[^1]: [Simple Exponential Smoothing](https://otexts.com/fpp2/ses.html)

Kita akan coba menggunakan data `rain_ts` yang kita miliki untuk
melakukan forecasting menggunakan SES.

```{r}
# visualisasikan rain
rain_ts %>% autoplot()
```

Data `rain_ts` tidak memiliki pola trend maupun seasonal. Karena datanya
polanya tahunan, oleh karena itu data rain tidak memiliki pola seasonal
yang dapat dilihat.

**SES**: ets(data, model = "\*NN")

Melakukan forecasting data `rain_ts` dengan metode SES (tidak
mempertimbangkan pola trend)

```{r}
# menggunakan fungsi `ets()`
rain_ses <- ets(y = rain_ts, model = "MNN")
rain_ses

rain_ses_auto <- ets(y = rain_ts, model = "ZNN")
# untuk melihat hasil predict menggunakan fitted values
rain_ses_auto$fitted
```

```{r}
sqrt(rain_ses_auto$mse)
```

```{r}
range(rain_ts)
```

```{r}
mean(rain_ts)
```

```{r}
rain_ts %>% 
  autoplot()+
  autolayer(rain_ses_auto$fitted)
```

> Insight: Apabila dilihat dari garis forecast terlihat hanya flat saja
> namun ternyata nilai forecastnya mendaekati nilai rata-rata datanya.
> Nilai prediksi yang menggunakan rata-rata data bisa memberikan error
> yang cukup kecil (berdasarkan teori OLS)

Menggunakan alpha = 0.03

```{r}
rain_ses2 <- ets(rain_ts, model = "ANN", alpha = 0.03)
rain_ses2$mse
```

Untuk membuat model SES menggunakan `HolWinters()` kita bisa setup
`beta = F`, dan `gamma = F` karena dalam model SES tidak memperhitungkan
efek trend dan seasonal. (default alpha, beta, dan gamma = NULL)

Visualisasi data historis dengan hasil forecast

```{r}
# gunakan autolayer()
rain_ts %>% 
  autoplot()+
  autolayer(rain_ses_auto$fitted, series = "alpha 0.0001")+
  autolayer(rain_ses2$fitted, series = "alpha 0.03")
```

> Kesimpulannya:

**Model evaluation**

Karena kita melakukan pemodelan tanpa cross validation kita tidak perlu
melakukan prediksi/forecast sebab hasil forecast data historis sudah
terdapat pada output hasil pemodelan. Kita dapat menghitung error yang
dihasilkan oleh model dengan menggunakan fungsi `accuracy()` dari
library `forecast`.

```{r}
# untuk melakukan forecasting
ses_forecast <- forecast(object = rain_ses_auto, # model yang akan digunakan untuk prediksi
                         h = 3) # banyak periode yang akan diprediksi, 3 artinya 3 periode
ses_forecast$mean
```

```{r}
# use accuracy
library(forecast)
# untuk melihat nilai error pada data train cukup memasukkan modelnya saja
accuracy(object = rain_ses_auto)
```

Untuk melihat nilai error menggunakan MAPE(Mean Absolute Percentage
Error), kita bisa tahu seberapa persen nilai error dari prediksi kita.

### Holt's Exponential Smoothing

**Holt's exponential (Double Exponential Smoothing)** digunakan untuk
data time series yang tidak mengandung efek seasonal[^2].

[^2]: [Trend Methods](https://otexts.com/fpp2/holt.html)

Melakukan forecasting data `co2_ts` dengan metode Holt's Exponential
menggunakan fungsi `HolWinters()`

```{r}
co2_ts %>% autoplot()
co2_holt <- HoltWinters(x = co2_ts, gamma = F)
co2_holt
```

```{r}
# output hasil forecast model
co2_holt$fitted[, 1]
```

Buatlah model untuk prediksi co2_ts, nilai alpha = 0.79 & 0.70 nilai
beta = 0.15 & 0.01

```{r}
# alpha 0.79 beta 0.15
co2_holt2 <- HoltWinters(co2_ts, alpha = 0.79, beta = 0.15, gamma = F)
  
# alpha 0.70 beta 0.01
co2_holt3 <- HoltWinters(co2_ts, alpha = 0.70, beta = 0.01, gamma = F)
```

Visualisasi data historis dengan hasil forecast

```{r}
# gunakan autolayer()
co2_ts %>% 
  autoplot()+
  autolayer(co2_holt$fitted[,1], series = "auto")+
  autolayer(co2_holt2$fitted[,1], series = "alpha = 0.79 beta 0.15")+
  autolayer(co2_holt3$fitted[,1], series = "alpha 0.7 beta 0.01")
  
```

**Kesimpulan**: dari ketiga model, walaupun MAPE nya lumayan kecil
sebesat \~6% namun apabila dilihat dari pergerakan hasil forecastnya
masih terlambat dalam mengikuti pola datanya (masih terdapat lagging)

Model evaluation

```{r}
# gunakan accuracy(hasil_prediksi, data_actual)
accuracy(co2_holt$fitted[,1], co2_ts)
accuracy(co2_holt2$fitted[,1], co2_ts)
accuracy(co2_holt3$fitted[,1], co2_ts)

```

**END OF DAY 2**

### Summary Day 2

-   Seasonal adjustment digunakan untuk menganalisa pola data time
    series tanpa menyertakan komponen seasonal. Tujuannya untuk melihat
    kenaikan dan penurunan trend data apakah benar-benar signifikan atau
    tidak.

-   Seasonal adjustment hanya digunakan untuk EDA.

-   Model forecasting:

    -   Simple Moving Average (SMA)

        -   digunakan pada data yang tidak terdapat trend dan seasonal
            (stasioner / bergerak disekitar rata-rata)
        -   ordo pada SMA tergantung user
        -   semakin besar ordo, maka hasil forecast akan semakin smooth
        -   pembuatan model menggunakan `SMA(data, n)`

    -   Simple Exponential Smoothing (SES)

        -   digunakan pada data yang tidak terdapat trend dan seasonal
            (stasioner / bergerak disekitar rata-rata)
        -   terdapat parameter smoothing untuk error yaitu alpha
        -   alpha nilainya 0-1
        -   alpha = \~1 artinya data terbaru diberikan bobot paling
            besar
        -   alpha = \~0 artinya data terbaru ataupun paling lama
            diberikan bobot yang tidak jauh berbeda
        -   untuk membuat model `ets(data, model = "*NN", alpha = NULL)`
            atau `HoltWinters(data, beta = F, gamma = F)`

    -   Holt Exponential Smoothing

        -   digunakan pada data tanpa memiliki komponen seasonal
        -   menggunakan parameter smoothing error = alpha, dan trend =
            beta
        -   pembuatan model `ets(data, model = "**N", alpha = NULL)`
            atau `HoltWinters(data, gamma = F)`

-   Model forecasting yang baik memiliki eror yang kecil dan pola
    forecasting tidak lagging terhadap data actualnya

# **START DAY 3**

### Holt's Winters Exponential

**Holt's Winters Exponential (Triple Exponential Smoothing)** merupakan
metode forecasting yang tepat digunakan untuk data yang memiliki efek
trend dan seasonal[^3].

[^3]: [Holt's Exponential
    Smoothing](https://otexts.com/fpp2/holt-winters.html)

#### Workflow Analisis Time Series

Business question: melakukan forecasting pada penjualan souvenir untuk 2
tahun kedepan.

1.  Read data `fancy.dat` dan simpan dengan nama object `souvenir`

```{r}
souvenir <- scan("data_input/fancy.dat")
souvenir
```

Data `souvenir` terdiri dari 84 observasi penjualan souvenir per bulan
dari tahun 1987.

2.  Buat time series object dan simpan dengan nama object `souvenir_ts`

```{r}
# Pak Sunarto
souvenir_ts <- ts(souvenir, start = 1987, frequency = 12) 
souvenir_ts
```

3.  Visualisasikan data `souvenir_ts`

Apakah tipe data time series yang terbentuk dari data `souvenir_ts`?

```{r}
souvenir_ts %>% autoplot()
```

Insight:

-   Penjualan souvenir paling tinggi ada dibulan Desember
-   Penjualan souvenir memiliki pola seasonal multiplikatif (tipe time
    series multiplikatif)
-   Dalam data tersebut memiliki komponen trend, seasonal, dan error
-   trend data memiliki pola multiplikative dan naik

4.  Decomposition

Tujuannya untuk menguraikan tipe-tipe data pada setiap komponen time
series yang ada agar tepat dalam penentuan pemilihan model untuk
forecast nya.

```{r}
# menguraikan komponen data time series
# Pak Yogie
souvenir_dc <- decompose(souvenir_ts, type = "multiplicative") 
souvenir_dc %>% autoplot()
```

5.  Splitting Data

-   Data train: 1987 - 1992 (6 tahun) simpan dengan nama object
    `souvenir_train`
-   Data test: 1993 (1 tahun) simpan dengan nama object `souvenir_test`

```{r}
# test menggunakan `tail()`
souvenir_test <- tail(souvenir_ts, 12)
# train menggunakan `head()`
# cara 1
souvenir_train <- head(souvenir_ts, length(souvenir_ts)-length(souvenir_test))
# cara 2
souvenir_train <- head(souvenir_ts, -length(souvenir_test))
```

6.  Melakukan model fitting pada data train `souvenir_train`

```{r}
# model multiplicative
model_hw <- HoltWinters(x = souvenir_train, seasonal = "multiplicative")
model_hw
```

7.  Melakukan prediksi pada data test `souvenir_test` dengan menggunakan
    fungsi `forecast()` dari library `forecast`

-   `object` = model time series
-   `h` = berapa banyak data kedepan yang akan di forecast

```{r}
# forecast menggunakan model multiplicative
forcast_souvenir <- forecast(object = model_hw, h = 12)
forcast_souvenir
```

-   `Point Forecast`: nilai forecast untuk periode yang ingin kita
    forecast
-   `Lo 80` & `Hi 80` : rentang tebakan dari hasil forecast untuk
    confidence level 80%
-   `Lo 95` & `Hi 95` : rentang tebakan dari hasil forecast untuk
    confidence level 95%

Visualisasi hasil forecast

```{r}
# visualisasi hasil forecast dari model multiplicative
souvenir_train %>% 
  autoplot()+
  autolayer(souvenir_test, series = "test")+ # data test
  autolayer(model_hw$fitted[,1], series = "fitted values")+ # fitted value data train
  autolayer(forcast_souvenir$mean, series = "forecast data test") # hasil forecast model 
```

```{r}
souvenir_ts %>% 
  autoplot()+
  autolayer(forcast_souvenir)
```

8.  Model evaluation menggunakan data `souvenir_test`

```{r}
# model multiplicative
accuracy(model_hw$fitted[, 1], souvenir_train) # untuk cek error train
accuracy(forcast_souvenir$mean, souvenir_test) # untuk cek error test
```

**Kesimpulan** Apabila dilihat dari visualisasi hasil forecast dengan
data actual tidak terdapat lagging walaupun hasil forecast cenderung
lebih tinggi nilainya. Dan jika dilihat dari nilai MAPE pada data train
dan data test terdapat perbedaan 8%, oleh karena itu saya akan anggap
sudah lumayan tidak terlalu overfit.

Tunning Model dimana data di transformasikan log

```{r}
souvenir_train_log <- log(souvenir_train)
souvenir_train_log %>% autoplot()
```

-   Modeling menggunakan data yang sudah di transformasi

```{r}
model_hw_log <- HoltWinters(x = souvenir_train_log, seasonal = "additive")
```

-   Forecasting

**Note**: Hasil forecast dari data yang sudah di transformasikan log
harus dikembalikan kembali ke bentuk data aslinya menggunakan `exp()`

```{r}
fcast_souv_log <- forecast(model_hw_log, h = 12)
fcast_souv <- exp(fcast_souv_log$mean)
```

-   Model evaluation

```{r}
accuracy(fcast_souv, souvenir_test)
```

### Knowledge Check

1.  Model forecasting manakah yang cocok digunakan untuk data yang tidak
    memiliki komponen trend dan seasonal? Dapat memilih lebih dari satu
    jawaban.

-   [x] Simple Moving Average
-   [x] Simple Exponential Smoothing
-   [ ] Holt Exponential Smoothing
-   [ ] Holt-Winter's Exponential Smoothing

2.  Grafik di bawah menunjukkan data tahunan total penumpang pesawat di
    Australia dari tahun 1970 sampai 2016. Berdasarkan pola data
    tersebut, model forecasting manakah yang cocok untuk data ini?

```{r echo=FALSE, eval=FALSE}
knitr::include_graphics("assets/ts.png")
```

-   [ ] Simple Moving Average
-   [ ] Simple Exponential Smoothing
-   [x] Holt Exponential Smoothing
-   [ ] Holt-Winters Exponential Smoothing

3.  Perhatikan grafik decompose dibawah ini. Berdasarkan grafik
    tersebut, tipe time series dan model forecasting apakah yang sesuai?
    Berikan alasannya...

```{r echo=FALSE, eval=FALSE}
knitr::include_graphics("assets/decompose.png")
```

> Tipe time series additive, model yang cocok digunakan yatu
> Holt-Winters Exponential Smoothing karena pada data tersebut memiliki
> komponen eror, trend, dan seasonal.

# ARIMA (Autoregressive Integrated Moving Average)

ARIMA adalah gabungan antara dua metode, yaitu *Auto Regressive* (AR)
dan *Moving Average* (MA). I nya menjelaskan *Integrated*. Tujuan utama
dari ARIMA adalah melakukan autocorrelation pada data.

## Stasionarity

Stasionarity time series memiliki arti bahwa pada data time series yang
kita miliki tidak memiliki trend maupun seasonal dan memiliki variansi
konstan[^4]. Berdasarkan gambar dibawah ini, manakah yang termasuk data
time series yang stasioner?

[^4]: [Stationarity and
    Differencing](https://otexts.com/fpp3/stationarity.html)

```{r echo=FALSE}
knitr::include_graphics("assets/ts-stasioner.png")
```

Apabila data yang kita miliki belum stasioner, maka kita bisa melakukan
differencing.

## Differencing

Jadi untuk membuat datanya stasioner, cara yang paling umum digunakan
adalah dengan melakukan differencing `diff`, yaitu mengurangi data saat
ini dengan data sebelumnya[^5]. Terkadang, tergantung pada kompleksitas
data, jumlah differencing bisa lebih dari 1 kali.

[^5]: [Explanation `diff()` in
    R](http://www.datasciencemadesimple.com/difference-function-in-r/)

**Pemahaman konsep mengapa perlu differencing???**

-   data sebelum dilakukan differencing

```{r}
data.frame(
  xt = c(AirPassengers),
  lag1 = lag(x = as.vector(AirPassengers), n = 1),
  lag2 = lag(x = as.vector(AirPassengers), n = 2),
  lag3 = lag(x = as.vector(AirPassengers), n = 3),
  lag4 = lag(x = as.vector(AirPassengers), n = 4),
  lag5 = lag(x = as.vector(AirPassengers), n = 5) 
) %>% 
  na.omit() %>% 
  GGally::ggcorr()
```

```{r}
diff(c(2,3,4,5,6,7))
```

-   data setelah dilakukan differencing

```{r}
data.frame(
  xt = c(diff(AirPassengers)),
  lag1 = lag(x = as.vector(diff(AirPassengers)), n = 1),
  lag2 = lag(x = as.vector(diff(AirPassengers)), n = 2),
  lag3 = lag(x = as.vector(diff(AirPassengers)), n = 3),
  lag4 = lag(x = as.vector(diff(AirPassengers)), n = 4),
  lag5 = lag(x = as.vector(diff(AirPassengers)), n = 5) 
) %>% 
  na.omit() %>% 
  GGally::ggcorr(label = T)
```

Ide utama melakukan differencing adalah agar ketika melakukan prediksi,
tidak ada multicolinearity terhadap data-data sebelumnya.

Model ARIMA:

ARIMA(p,d,q)

## AR(p) : Auto Regressive

**Auto regressive** di ARIMA artinya kita membuat model linear
regression berdasarkan lag dari datanya sebagai prediktor[^6]. Linear
regression models, baik ketika prediktornya tidak ada korelasi dan
independen satu dengan lainnya. Nilai `p` berarti berapa banyak data
yang akan dipakai ketika melakukan auto regressive.

[^6]: [Auto Regression Model](https://otexts.com/fpp2/AR.html)

Model autoregressive dapat dituliskan sebagai berikut.

$$
Y_t = \alpha + \beta_1Y_{t-1}+\beta_2Y_{t-2}+...+\beta_pY_{t-p}+ \epsilon_1
$$

dimana, $Y_{t-1}$ adalah lag1, $\beta_1$ adalah coefficient dari lag1,
dan $\alpha$ adalah intercept.

## MA(q) : Moving Average

**Moving Average** dalam ARIMA artinya kita melakukan rata-rata berjalan
terhadap data time series itu sendiri[^7].

[^7]: [Moving Average Model](https://otexts.com/fpp2/MA.html)

Moving Average Model (MA model).

$$
Y_t = \alpha + \epsilon_t + \phi_1\epsilon_{t-1}+\phi_2\epsilon_{t-2}+...+\phi_q\epsilon_{t-q}
$$

Arima memiliki bentuk model (p,d,q) dimana[^8] :

[^8]: [Non Seasonal
    Model](https://otexts.com/fpp2/non-seasonal-arima.html)

-   Auto Regressive -> AR(p)\
    AR ini mirip dengan regresi linear, hanya saja dia melakukan regresi
    terhadap dirinya sendiri. Nilai `p` berarti berapa banyak data yang
    akan dipakai ketika melakukan auto regressive.

Untuk mencari order p untuk model AR, kita dapat melihat dari plot PACF
(Partial Autocorrelation Function).

> autokorelasi pada saat t dan t - k tanpa dipengaruhi oleh korelasi
> periode ditengahnya (intermediate lags). Misalnya autokorelasi untuk
> lag(2) maka bisa dikatakan ingin mencari autokorelasi antara hari rabu
> ke jumat secara langsung.

-   Integrated -> I(d)\
    Integrated adalah berapa kali data dilakukan differencing untuk
    membuat suatu data stationer. Nilai `d` dapat diketahui dengan
    mencari tahu berapa kali differencing yang dilakukan pada data.

-   Moving Average -> MA(q)\
    MA digunakan untuk melakukan smoothing error. Nilai `q` berarti
    berapa banyak data yang diperlukan untuk smoothing error menggunakan
    moving average.

Untuk mencari order q untuk model MA, kita dapat melihat dari plot ACF
(Auto correlation Function)

> mencari autokorelasi pada saat t dan t - k, dan dipengaruhi oleh
> periode ditengahnya. Misal: autokorelasi untuk lag(2) maka bisa
> dikatakan, akan dihitung nilai autokorelasi di hari jumat ke rabu,
> namun mempertimbangkan korelasi antara jumat ke kamis dan kamis ke
> rabu.

**Tahap analisis menggunakan metode ARIMA:**

1.  Objek time series
2.  Melakukan pengujian stasioner menggunakan `adf.test`

H0 : data tidak stasioner H1 : data stasioner

> kita mengharapkan p-value \< alpha, sehingga pola data stasioner

3.  Catat informasi berapa kali dilakukan differencing sampai data
    menjadi stasioner
4.  Lakukan pembuatan model arima menggunakan
    `auto.arima(objek_ts, seasonal = F)`.
5.  Tuning model dengan mencari ordo (p) dan (q) secara manual.

-   plot acf vs pacf untuk mencari ordo (p) dan (q) secara manual
-   acf (autocorrelation function), pacf (partial autocorrelation
    function).
-   acf: mencari autokorelasi pada saat t dan t - k, dan diperngaruhi
    oleh periode ditengahnya. Misal: autokorelasi untuk lag(2) maka bisa
    dikatakan, akan dihitung nilai autokorelasi di hari jumat ke rabu,
    namun mempertimbangkan korelasi antara jumat ke kamus dan kamis ke
    rabu.
-   pacf: mencari autokorelasi pada saat t dan t - k tanpa dipengaruhi
    oleh korelasi periode ditengahnya.

6.  Memperhatikan pola dari plot acf dan pacf. Dimana ada dua tipe pola
    yaitu: `tails off` atau `cuts of lag`.

-   `tails off`: garis saat lag ke-1 mengalami penurunan yang lambat.
-   `cuts off lag`: garis saat lag ke-1 mengalami penurunan yang cepat.

```{r echo=FALSE}
knitr::include_graphics("assets/arima-table.png")
```

7.  Memperhatikan garis keluar dari batas pada lag ke berapa saja.
    (signifikan pada lag ke berapa aja)

-   membuat model perbandingan dari beberapa kemungkinan ordo nya
-   mencari model terbaik dari nilai AIC yang terkecil

8.  Model evaluation dengan nilai MAPE
9.  Cek asumsi time series

-   normality residual assumption
-   autocorrelation residual assumption

**END OF DAY 3**

# **START OF DAY 4**

## Non-Seasonal ARIMA(p,d,q)

Kita akan coba melakukan forecast pada data `environment_1970f.csv`,
dimana yang akan kita ubah kedalam bentuk object time series adalah data
`Nitrous.oxide.emissions..thousand.metric.tons.of.CO2.equivalent.`

1.  Read Data

```{r}
nitro <- read.csv("data_input/environment_1970f.csv")
head(nitro)
```

2.  Membuat object time series untuk kolom
    `Nitrous.oxide.emissions..thousand.metric.tons.of.CO2.equivalent.`

```{r}
no_ts <- ts(data = nitro$Nitrous.oxide.emissions..thousand.metric.tons.of.CO2.equivalent., start = 1970, 
            frequency = 1)
no_ts
```

```{r}
class(no_ts)
```

3.  Melakukan pengecekan object ts stasioner

Stasioner adalah data yang bergerak disekitar rata-rata globalnya.

-   melihat berdasarkan visual

```{r}
no_ts %>% autoplot()
```

> justifikasi diawal, karena datanya terdapat trend naik, artinya data
> belum stasioner, perlu distasionerkan

-   melakukan pengujian menggunakan `adf.test()`

H0: data tidak stasioner

H1: data stasioner

```{r}
adf.test(no_ts)
```

> dengan alpah = 5%, p-value \> alpha artinya gagal tolak H0, jadi
> datanya belum stasioner.

4.  Melakukan differencing data agar stasioner

-   mencoba melakukan pengujian data `no_ts` dengan satu kali
    differencing

```{r}
# differencing 1x
diff(no_ts) %>% 
  adf.test() # lanjut dilakukan pengecekan stasioneritas
```

Data kita perlu dilakukan differencing 1x hingga dia stasioner.

ARIMA(p,d,q)

d -> diperoleh dari hasil berapa kali melakukan differencing = 1

> artinya nilai d pada ARIMA(p,d,q) = 1

```{r eval=FALSE}
# diff lebih dari 1 kali menggunakan parameter `differences`
diff(no_ts, differences = 2) %>% adf.test()
```

5.  Model Fitting

-   **melakukan tunning model untuk p, d, dan q nya menggunakan acf dan
    pacf**

p = melihat lag yang keluar dari plot PACF (partial autocorrelation
function) q = melihat lag yang keluar dari plot ACF (autocorrelation
function)

ACF untuk melihat korelasi suatu data dengan mempertimbangkan data
tengahnya. misal ingin melihat korelasi hari senin dengan hari rabu,
kita harus mempertimbangkan:

-   korelasi hari senin - selasa
-   korelasi hari senin - rabu
-   korelasi hari selasa - rabu

PACF untuk melihat korelasi data tanpa mempertimbangkan data tengahnya.
misal ingin melihat korelasi hari senin dengan rabu, cukup melihat nilai
korelasi hari senin - rabu saja

melihat plot pacf dan acf untuk menemukan nilai `p` dan `q`

```{r}
# melihat plot acf dan pacf menggunakan `tsdisplay()`
diff(no_ts) %>% tsdisplay()
```

nilai p yang diperoleh dari 5 lag pertama yang keluar dari plot pacf

> p = 1/2/4/0

nilai q yang diperoleh dari 5 lag pertama yang kelaur dari plot acf

> q = 1/0

Kombinasi model ARIMA yang terbentuk[^9] :

[^9]: [ARIMA in R](https://otexts.com/fpp2/arima-r.html)

ARIMA(p,d,q)

-   ARIMA\[1,1,1\]
-   ARIMA\[1,1,0\]
-   ARIMA\[2,1,1\]

parameter pada fungsi `Arima()`

-   y = object time series
-   order = nilai (p,d,q)

```{r}
# ARIMA[1,1,1]
model_arima1 <- Arima(y = no_ts, order = c(1,1,1))
model_arima1
```

```{r}
model_arima2 <- Arima(no_ts, order = c(1,1,0))
model_arima3 <- Arima(no_ts, order = c(2,1,1))
```

-   perbandingan model terbaik berdasarkan nilai AIC

```{r}
model_arima1$aic
model_arima2$aic
model_arima3$aic
```

-   membuat model arima secara otomatis menggunakan `auto.arima()`

```{r}
model_auto <- auto.arima(no_ts)
```

6.  Goodness of Fit (Pemilihan model terbaik)

Untuk pemilihan model terbaik kita bisa melihat nilai AIC dari
masing-masing model yang paling kecil

```{r}
model_arima1$aic
model_arima2$aic
model_arima3$aic
model_auto$aic # ARIMA(0,1,1)
```

7.  Model Evaluation

-   bisa menggunakan fungsi `accuracy()` dari package `forecast` untuk
    melihat MAPE

```{r}
accuracy(model_auto)
```

```{r}
no_ts %>% autoplot()+
  autolayer(model_auto$fitted)
```

## Seasonal ARIMA (SARIMA(p,d,q)(P,D,Q)\[seasonal\])

Seasonal arima adalah metode arima dimana object time series yang ada
memiliki pola seasonal[^10]. Tahapan dalam melakukan pemodelan
menggunakan SARIMA sama seperti saat membuat pemodelan ARIMA.

[^10]: [Seasonal ARIMA](https://otexts.com/fpp2/seasonal-arima.html)

Order Model pada SARIMA(p,d,q)(P,D,Q)\[seasonal\]

ARIMA: (p, d, q)

SARIMA: (p, d, q)(P, D, Q)\[seasonal\]

-   (p, d, q) untuk index utama

-   (P, D, Q) untuk index seasonal

-   seasonal merupakan frequency

Jika kita menggunakan model SARIMA, diperlukan langkah tambahan ketika
melakukan differencing untuk seasonal data, yaitu **differencing sesuai
pola berulang/frequency** data time series untuk menghilangkan pola
musiman.

Pada bagian ini, kita akan menggunakan data `DAUTONSA.csv` yaitu data
penjualan motor perbulan dari Jan 1967 - Jun 2019.

1.  Read data

```{r}
sales <- read.csv("data_input/DAUTONSA.csv")
head(sales)
```

-   untuk kebutuhan analisis, datanya akan kita subset dari tahun 2011
    keatas

```{r}
sales <- sales %>% 
  mutate(DATE = ymd(DATE)) %>% 
  filter(DATE >= ymd("2011-01-01"))
sales %>% head()

```

2.  Membuat object time series, dimana periode bermula dari Januari 2011

```{r}
sales_ts <- ts(data = sales$DAUTONSA, start = c(2011, 1), frequency = 12)
```

Melihat visualisasi data secara umum

```{r}
sales_ts %>% autoplot()
```

Informasi dari object `sales_ts`:

-   dari data `sales_ts` terdapat seasonality
-   dari data `sales_ts` terdapat trend naik pada tahun 2011-2014, namun
    pada tahun 2015-2019 terjadi penurunan
-   dari data `sales_ts` terlihat masih belum stasioner

3.  Splitting data

Test data : sisanya Train data : diambil 7 tahun pertama

```{r}
sales_train <- head(sales_ts, 7*12)
sales_test <- tail(sales_ts, -length(sales_train))
```

4.  Melakukan pengecekan stasionaritas data train

```{r}
# mencoba dengan seasonal period (frequency)
adf.test(sales_train)
```

> karena p-value \> alpha, dimana 0.192 \> 0.05 artinya data belum
> stasioner

Differencing based on frequency, cek apakah sudah stasioner atau belum

> **Notes**: Untuk differencing seasonal, kita akan gunakan parameter
> `lag` dimana nilainya mengikuti frekuensi data yang kita miliki

```{r}
# melakukan satu kali differencing untuk menghilangkan efek seasonal (1x)
diff(sales_train, lag = 12) %>% # differencing untuk seasonal 1x
  diff() %>% # differencing untuk trend 1x
  adf.test()
```

d = 1 -> differencing trend D = 1 -> differencing seasonal

5.  Model Fitting

-   membuat model SARIMA menggunakan `auto.arima()`

SARIMA(p,d,q)(P,D,Q)\[seasonal/freq\]

```{r}
model_auto_sarima <- auto.arima(sales_train, seasonal = T)
model_auto_sarima
```

-   tunning model SARIMA secara manual

Menentukan nilai (p,d,q)(P,D,Q)seasonal

Langkah 1: Tentukan `D`.

Langkah 2: Tentukan `d`.

Langkah 3: Tentukan `P dan Q`. Untuk index seasonal, amati berapa banyak
lag yang keluar di ACF/PACF ketika lag = freq/kelipatan freq.

```{r}
# untuk menampilkan banyak lag yang muncul di plot acf dan pacf bisa tambahkan `lag.max`
diff(sales_train, lag = 12) %>% 
  diff() %>% 
  tsdisplay(lag.max = 36)
```

Untuk seasosal menentukan P dan Q kita melihat kelipatan lag berdasarkan
frequenci data kita.

-   P : 0
-   D : 1
-   Q : 0

untuk keseluruhan data menentukan p dan q kita melihat 5 lag pertama
yang keluar

-   p: 1/2
-   d: 1
-   q: 1

Kombinasi model yang mungkin terbentuk adalah :

SARIMA(p,d,q)(P,D,Q)\[12\]

-   SARIMA(1,1,1)(0,1,0)\[12\]

-   SARIMA(2,1,1)(0,1,0)\[12\]

-   SARIMA(0,1,1)(0,1,0)\[12\]

-   SARIMA (1,1,1)(0,1,0)\[12\]

```{r}
# order = (p,d,q), seasonal = (P,D,Q)
model_sarima1 <- Arima(sales_train, order = c(1,1,1), seasonal = c(0,1,0))
model_sarima2 <- Arima(sales_train, order = c(2,1,1), seasonal = c(0,1,0))
model_sarima3 <- Arima(sales_train, order = c(0,1,1), seasonal = c(0,1,0))
```

Goodness of fit menggunakan nilai AIC

```{r}
model_sarima1$aic
model_sarima2$aic
model_sarima3$aic # modelnya sama seperti bentuk auto sarima
model_auto_sarima$aic
```

6.  Melakukan forecasting untuk 18 bulan kedepan

```{r}
# forecast, h = 18
length(sales_test)
sales_forecast <- forecast(model_sarima3, h = 18)
```

Visualisasi

```{r}
# menggunakan autoplot dan autolayer
sales_train %>% 
  autoplot()+
  autolayer(sales_test)+
  autolayer(sales_forecast$mean)
```

7.  Model evaluation

-   menggunakan `accuracy()` dari package `forecast` dan melihat nilai
    MAPEnya

```{r}
# accuracy

accuracy(model_sarima3$fitted, sales_train) # error train
accuracy(sales_forecast$mean, sales_test) # error test
```

# Assumption

Asumsi pada time series diujikan untuk mengukur apakah residual yang
peroleh dari hasil modeling sudah cukup baik untuk menggambarkan dan
menangkap informasi pada data. Mengapa menggunakan residual data? Karena
dengan menggunakan residual data, kita dapat mendapatkan informasi dari
data aktual maupun dari hasil prediksi menggunakan model. Metode
forecasting yang baik menghasilkan nilai residual berikut ini[^11]:

[^11]: [Residuals Diagnostic](https://otexts.com/fpp2/residuals.html)

1.  Residual yang tidak berkorelasi. Apabila terdapat residual yang
    berkorelasi, artinya masih terdapat informasi yang tertinggal yang
    seharusnya digunakan untuk menghitung hasil forecast.
2.  Residual memiliki rata-rata 0.

Untuk memastikan bahwa residual yang dihasilkan memiliki kriteria
diatas, maka terdapat asumsi untuk mengujinya.

## No-autocorrelation residual

$H_0$: residual has no-autocorrelation

$H_1$: residual has autocorrelation

**yang diinginkan p-value \> 0.05 (alpha), no-autocorrelation**

Untuk mengecek ada/tidaknya autokorelasi pada hasil forecasting time
series bisa menggunakan beberapa cara, yaitu:

-   menggunakan visualisasi plot residual acf dengan fungsi
    `acf(residual model)`

```{r}
# menggunakan visualisasi
acf(model_sarima3$residuals)
```

> untuk mengetahui ada atau tidaknya autocorrelation, kita lihat dari
> lag 1 - terakhir tidak ada yang keluar garis putus-putus. Berdasarkan
> acf residual model, masih ada lag yang keluar garis putus-putus, bisa
> saja ada indikasi bahwa model yang dimiliki terdapat autocorrelation

-   melakukan uji Ljung-box dengan menggunakan fungsi
    `Box.test(residual model, type = "Ljung-Box)`

> $H_0$: residual has no-autocorrelation
>
> $H_1$: residual has autocorrelation

```{r}
# menggunakan Ljung-Box test
Box.test(model_sarima3$residuals, type = "Ljung-Box")
```

> pada Ljung-Box test diats, p-value \> alpha, dimana 0.78 \> 0.05
> artinya gagal tolak H0, artinya residual/eror pada data tidak terdapat
> autocorrelation

## Normality of residual

> $H_0$: residual menyebar normal
>
> $H_1$: residual tidak menyebar normal

**yang diinginkan p-value \> 0.05 (alpha), residual menyebar normal**

Untuk mengecek normality residual pada hasil forecasting time series
kita bisa melakukan uji normality (shapiro test) dengan menggunakan
fungsi `shapiro.test(residual model)`

```{r}
shapiro.test(model_sarima3$residuals)
```

> karena p-value \< alpha, dimana 0.027 \< 0.05, maka residual belum
> berdistribusi normal

```{r}
hist(model_sarima3$residuals)
```

**Note** : Untuk mengecek asumsi cukup di model yang memang paling baik.

# \[Additional\] STLM (Seasonal Trend with Loess Model)

Apabila dalam decompose biasa, dalam mendapatkan komponen trend dengan
cara central moving average (CMA) dimana secara konsep setiap data yang
ingin dirata-ratakan diberikan bobot yang sama sesuai ordo yang
ditetapkan. Karena merata-ratakan data tengahnya hasilnya kita
kehilangan data awal dan data akhirnya, sehingga ada beberapa informasi
yang hilang. Ada salah satu cara untuk mendapatkan decompose data namun
tetap mempertahankan informasi dari seluruh data yang kita miliki yaitu
dengan menggunakan **STL(Seasonal Trend with Loess)**. STL secara konsep
akan melakukan smoothing terhadap data tetangga setiap masing-masing
observasi dengan memberikan bobot yang lebih berat terhadap data yang
dekat dengan observed data. Kekurangan dari STL hanya bisa melakukan
decompose pada additive data, apabila terdapat multiplicative data dapat
menggunakan transformasi `log()`\[\^12\].

Untuk memodelkan hasil STL, kita bisa menerapkan STLM(Seasonal Trend
with Loess Model) dimana kita bisa menerapkan metode exponential
smoothing (ETS) dan ARIMA. Selain itu, STLM dapat digunakan sebagai
alternative cara untuk menangkap seasonal yang belum bisa ditangkap oleh
metode ETS dan ARIMA biasa.

## Decompose menggunakan `stl()`

Dengan menggunakan data rata-rata penjualan souvenir per bulan yang kita
miliki, kita kan coba melakukan decompose dengan `stl()` dan memodelkan
dengan menggunakan fungsi `stlm()` dengan menerapkan metode arima.

Perlu mengatur parameter `s.window` untuk mendefinisikan pola seasonal
yang ingin ditangkap dengan melakukan transformasi log pada data train
dan test.

```{r}
souvenir_train %>% decompose(type = "multiplicative") %>% autoplot()
log(souvenir_train) %>% stl(s.window = 12) %>% autoplot()
```

## Modeling

Dengan menggunakan informasi data train `sales_train` dan test
`sales_test`, kita akan coba untuk membuat model dengan menggunakan
metode `stlm()` dengan mengatur parameter `method = "ets"`.

Parameter `stlm()` yang harus di atur:

-   `y` : object time series

-   `s.window` : pola seasonal yang ingin ditangkap

-   `method` : metode forecast yang akan digunakan, tersedia `ets` dan
    `arima`

-   modeling

```{r}
model_stlm <- stlm(y = log(souvenir_train), s.window = 12, method = "ets")
```

## Forecasting

Melakukan forecast untuk 12 bulan mendatang

```{r}
forecast_stlm <- forecast(model_stlm, h = 12)
```

Visualisasi hasil forecast

```{r}
souvenir_ts %>% autoplot(series = "actual") +
  autolayer(souvenir_test, series = "test data") +
  autolayer(exp(forecast_stlm$mean), series = "forecast") +
  scale_color_manual(values = c("black", "blue", "firebrick"))
```

## Model Evaluation

Melakukan evaluasi model dengan menggunakan fungsi `MAPE()` dari package
`MLmetrics`

```{r}
library(MLmetrics)
MAPE(y_pred = exp(forecast_stlm$mean), y_true = souvenir_test)*100
accuracy(exp(forecast_stlm$mean), souvenir_test)
accuracy(souvenir_forecast$mean, souvenir_test)
```

# Reference

More resource to learn more :

-   [ARIMA vs ETS](https://otexts.com/fpp2/arima-ets.html)
-   [Regression ARIMA](https://otexts.com/fpp2/regarima.html)
-   [Multiple Seasonal Time
    Series](https://algotech.netlify.com/blog/multiple-seasonal/)
-   [Multiple Seasonal using
    Purrr](https://algotech.netlify.com/blog/purrr-operly-fitting-multiple-time-series-model/)
-   [Theil's
    U](https://docs.oracle.com/cd/E57185_01/CBREG/ch06s02s03s04.html)
-   [Time Series
    Metrics](http://www.edscave.com/forecasting---time-series-metrics.html)
